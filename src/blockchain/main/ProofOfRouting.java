package blockchain.main;

import java.security.*;
import java.util.*;

public class ProofOfRouting {
    /*Stopword from which the PoR recognizes it got to the first layer*/
    private static String keyword = "this is a secret";
    /*Used this data structure to ensure that no device repeats itself*/
    private LinkedHashMap<String, String> participantsTable;
    /*Signatures are meant to be added on the same order as participants
    * An it generates the layer structure of the PoR
    * Signatures are also the way to provide non repudiation*/
    private ArrayList<String> signatures;
    /* The proof of routing is generated by the sender
    * therefore it needs to identify himself */
    private String senderId;
    /* ReceiverId is a way to validate since the creator
    * of the transaction containing this PoR has to be
    * the same id as the receiverId stated by the sender */
    private String receiverId;
    /* Allows to keep the encryption algorithm customization */
    private String algorithm;


    public ProofOfRouting(String senderId, String receiverId, String algorithm) {
        this.participantsTable = new LinkedHashMap<>();
        this.signatures = new ArrayList<>();
        this.senderId = senderId;
        this.receiverId = receiverId;
        this.algorithm = algorithm;
    }

    /* Linked dependency on hash for signatures, same as blockchain works with blocks ids */
    public void addRouter(Device device) {
        String keyword = signatures.size() != 0 ? signatures.get(signatures.size() - 1) : ProofOfRouting.keyword;

        String signature = device.sign(keyword);

        this.signatures.add(signature);
        this.participantsTable.put(device.getId(), device.getPublicKey());
    }

    /* To verify in a step if the id correlates to the signature */
    private boolean localVerify(String keyword, String signature, String id) {
        PublicKey publicKey = IdentityUtil.getPublicKey(this.participantsTable.get(id), this.algorithm);
        return SignatureUtil.verify(publicKey, keyword, signature.getBytes(), this.algorithm);
    }

    /* Verifies step by step if each Id corresponds to the signature */
    public boolean verify(){
        if (this.participantsTable.isEmpty()) return false;
        boolean result = true;
        String[] participants = this.participantsTable.keySet().toArray(new String[this.participantsTable.size()]);
        for(int i = this.participantsTable.size() - 1; i >= 0; i--) {
            try {

                result = result && localVerify(i == 0 ? ProofOfRouting.keyword : this.signatures.get(i-1), this.signatures.get(i), participants[i]);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    public ArrayList<String> getParticipantsId() {
        return new ArrayList<>(this.participantsTable.keySet());
    }

    public ArrayList<String> getParticipantsKeys() {
        return new ArrayList<>(this.participantsTable.values());
    }

    public String getSenderId() {
        return this.senderId;
    }

    public String getReceiverId() {
        return this.receiverId;
    }

    public ArrayList<String> getSignatures() {
        return this.signatures;
    }
}
