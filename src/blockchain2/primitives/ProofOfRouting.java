package blockchain2.primitives;

import blockchain2.crypto.CryptoProvider;
import blockchain2.device.Device;
import core.DTNHost;
import lombok.Getter;

import java.security.InvalidKeyException;
import java.security.PublicKey;
import java.security.SignatureException;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.IntStream;


public class ProofOfRouting {
    /*Stopword from which the PoR recognizes it got to the first layer*/
    private final static String keyword = "this is a secret";
    /*Used this data structure to ensure that no device repeats itself*/
    private final Map<String, PublicKey> participantsTable;
    /*Signatures are meant to be added on the same order as participants
    * An it generates the layer structure of the PoR
    * Signatures are also the way to provide non repudiation*/
    @Getter private final List<String> signatures;
    /* The proof of routing is generated by the sender
    * therefore it needs to identify himself */
    @Getter private final PublicKey senderKey;
    @Getter private final String senderId;
    /* ReceiverId is a way to validate since the creator
    * of the transaction containing this PoR has to be
    * the same id as the receiverId stated by the sender */
    @Getter private final PublicKey receiverKey;
    @Getter private final String receiverId;


    public ProofOfRouting(final PublicKey senderKey, final PublicKey receiverKey, final String senderId, final String receiverId) {
        this.participantsTable = new LinkedHashMap<>();
        this.signatures = new ArrayList<>();
        this.senderKey = senderKey;
        this.receiverKey = receiverKey;
        this.senderId = senderId;
        this.receiverId = receiverId;
    }

    /* Linked dependency on hash for signatures, same as blockchain works with blocks ids */
    public void addRouter(final Device device) throws SignatureException, InvalidKeyException {
        final String keyword = signatures.size() != 0 ? signatures.get(signatures.size() - 1) : ProofOfRouting.keyword;

        final String signature = device.sign(keyword);

        this.signatures.add(signature);
        this.participantsTable.put(device.getId(), device.getPublicKey());
    }

    /* Verifies step by step if each Id corresponds to the signature */
    public Boolean verify(final CryptoProvider cryptoProvider) throws SignatureException, InvalidKeyException {
        if (this.participantsTable.isEmpty()) {
            return false;
        }
        final List<String> participants = new ArrayList<>(this.participantsTable.keySet());
        boolean accumulatedVerification = true;
        for (int i = 0; i < participants.size(); i++) {
            final int index = participants.size() - i;
            accumulatedVerification = accumulatedVerification && localVerify(index == 0 ? ProofOfRouting.keyword : this.signatures.get(index - 1),
                    this.signatures.get(index),
                    participants.get(index),
                    cryptoProvider);
        }
        return accumulatedVerification;
    }

    public List<String> getParticipantsId() {
        return new ArrayList<>(this.participantsTable.keySet());
    }

    public List<PublicKey> getParticipantsKeys() {
        return new ArrayList<>(this.participantsTable.values());
    }

    /* To verify in a step if the id correlates to the signature */
    private Boolean localVerify(final String keyword,
                                final String signature,
                                final String id,
                                final CryptoProvider provider) throws SignatureException, InvalidKeyException {
        final PublicKey publicKey = this.participantsTable.get(id);
        return provider.verify(publicKey, keyword, signature.getBytes());
    }
}
